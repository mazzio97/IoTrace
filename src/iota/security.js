import { Security } from '../simulation/constants.js'
var crypto = require('asymmetric-crypto')


class SecurityToolBox {
    constructor() {
        // this.password = this.generatePassword()
        this.keys = crypto.keyPair()
        console.log(this.keys)
    }

    generatePassword() {
        /**
         * @returns a password using settings specified in Security
         */
        var pass = ""
        for (var i = 0, n = Security.password_charset.length; i < Security.password_length; ++i) {
            pass += Security.password_charset.charAt(Math.floor(Math.random() * n))
        }
        return pass
    }

    encryptMessage(message, receiver_public_key) {
        /**
         * @param message plaintext to encrypt
         * @param receiver_public_key receiver's public key used to encrypt,
         * only the receiver will be able to read the message decrypting with
         * its own secret private key
         * 
         * @returns the ciphertext
         */
        return crypto.encrypt(message, receiver_public_key, this.keys.secretKey)
    }

    decryptMessage(ciphertext, sender_public_key) {
        /**
         * @param message encrypted data and nonce
         * @param sender_public_key sender's public key used to verify the 
         * sender's identity
         * 
         * @returns the decrypted message
         */
        return crypto.decrypt(ciphertext.data, ciphertext.nonce, sender_public_key, this.keys.secretKey)
    }

    signMessage(ciphertext) {
        /**
         * @param ciphertext an encrypted message containing data and nonce
         * 
         * @returns the signature for this message to verify in the future the identity of
         * the sender 
         */
        return crypto.sign(ciphertext.data, this.keys.secretKey)
    }

    verifyMessage(ciphertext, signature, sender_public_key) {
        /**
         * @param ciphertext an encrypted message containing data and nonce
         * @param signature the signature generated by the the entity who wants to 
         * prove that it is also the author of the message 
         * @param sender_public_key sender's public key
         * 
         * @returns true if the signature matches
         */
        return crypto.verify(ciphertext.data, signature, sender_public_key)
    }
}

export { SecurityToolBox }